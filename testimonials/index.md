---
layout: page
title: Testimonials | The F# Software Foundation
headline: Tell us about F#
class: testimonials
---

### Academia and research

> "F#...levels the playing field between beginners and experienced programmers."

 - Prof Susan Eisenbach
 - Dean of Learning and Teaching Imperial College, United Kingdom 

Functional languages are ideal for teaching clear thinking, for solving problems 
amenable to code solutions and it levels the playing field between beginners and 
experienced programmers. The first programming language taught has a substantial 
influence on what language students use when they have a free choice. F#, once it 
is platform independent, has the potential to become the first programming language. 

<div class="keywords">teaching research</div>

---

> "F#...made it trivial..." 

 - **Prof David Walker**
 - Princeton University, United States,

Our graduate course on Parallelism this Fall is full, even though it assumes no 
experience with functional programming or F#. The students are preparing the courseware 
themselves, and one of the topics we are studying is functional reactive programming (FRP) 
with continuous, time-varying behaviors. F#, with its rich graphics libraries, made it 
trivial to construct a super-fun assignment involving purely functional and interactive 
animation of a mock solar system.

<div class="keywords">teaching research</div>

---

> "When F# is combined with Visual Studio... productivity goes through the roof!"

 - **Professor Nigel Horspool**
 - University of Victoria, Canada

F# programs tend to be much shorter than their equivalents in other languages, and the 
fewer lines of code required, of course, the higher the productivity. When F# is combined 
with Visual Studio, which provides help with remembering the methods attached to different 
data types and how to use those methods, productivity goes through the roof!

<div class="keywords">teaching research</div>

---

### Finance, Insurance and Trading

> "Either it wont compile or its correct"

 - **Simon Cousins**
 - [In what areas might the use of F# be more appropriate than C#?](http://stackoverflow.com/questions/2785029/in-what-areas-might-the-use-of-f-be-more-appropriate-than-c)

I have written an application to balance the national power generation schedule for a portfolio 
of power stations to a trading position for an energy company. The client and server components 
were in C# but the calculation engine was written in F#. 

The use of F# to address the complexity at the heart of this application clearly demonstrates 
a sweet spot for the language within enterprise software, namely algorithmically complex 
analysis of large data sets. My experience has been a very positive one.

<div class="keywords">trading</div>

---

> "the core logic is written in F# wherever possible" 

- **Andrea D'Intino**
- Yellow blue soft
- [The evolution of a GUI and the pulsating life of a UX](http://tabbles-dev.blogspot.co.uk/2009/12/tabbles-museum-evolution-of-gui-and-of.html)

#### Tabbles

Yellow blue soft is a truly international Micro-ISV: We are a small, dynamic and international 
team who is wondering why file-management is lagging 30 years behind and no one seems to care 
or even notice. We do. We love what we're doing and most importantly we love listening to you! 
Visit our blog to know more about us and join our forum to become part of our sparkling community.

Our goals: Revolutionize the way files are managed. Enhance teamwork by improving file management for groups.
Developed software based on what you need.

The tabbles are special containers that you can use to categorize any kind of file and document as 
well as folders and bookmarks. Using Tabbles you can quickly categorize, find, sort and share your 
documents, in a totally new way.

<div class="keywords">applications</div>

---

> "risk and analytic capabilities (...) are entirely written in F#

 - **Laurence Austen**
 - Chief Risk Officer at [Trafigura](http://cufp.org/users/lawrenceausten)
 - [F# Machine Learning in Finance](http://cs.hubfs.net/topic/None/59847)

#### Trafigura, Oil and Gas Commodity Traders

You will work directly with Trafigura's Chief Risk Officer/Head of Quantitative Analysis, 
"cranking code" and rapidly extending our risk and analytic capabilities, which are entirely 
written in F#. 

Trafigura Limited engages in the supply and offtake of crude oil, petroleum products, liquefied 
petroleum gas, metals, and metal ores and concentrates worldwide. Its solutions include trading, 
financing, hedging, and logistical support. The company involves in oil, metals, and minerals 
trading and investment activities, as well as in trade and project finance, and storage and 
distribution operations. It also provides wholesale power to industrial enterprises and municipalities 
in Italy. The company was formerly known as Raw Material Services Limited and changed its name 
to Trafigura Limited in May 1993. The company was incorporated in 1992 and is based in London, 
United Kingdom with addition...

<div class="keywords">risk analytics</div>

---

> ...we have decided to use F# as functional language to  have automatic integration with rest of the system...

- **EMEA-based Security Solutions Company**

We develop security product to protect critical infrastructure (e.g. Oil Refinery, Airport, etc) for countries across the globe. …. In core of our product there are prediction algorithms. We use different modeling and theorems (Monte Carlo, Action, etc) to implement the prediction components. … Since we are rewriting our next generation product using .NET, we have decided to use F# as functional language to  have automatic integration with rest of the system. … We also have advanced machine learning components (Artificial Intelligence) and functional languages are the best fit to write AI stuff. We are planning to use F# as the primary programming language in this area because of its interoperability with .NET. 

---

> When the calculation requires a proper algorithm … our choice has been F#.

- London-Based Asset Management Company

We have set up a complete risk management system that combines several data sources, presents them in a … WPF user interface, and does a LOT of calculation behind the scenes. When the calculation requires a proper algorithm (i.e. anything that is more complex than a simple for loop), our choice has been F#. I have to say I keep being surprised by how compact it is and, nonetheless, how readable it is even when I’m reading code that I hadn’t looked at or thought about for six months.

---

> F# rocks - building out various algorithms for DNA processing here and 
> it's like a drug

- **Darren Platt**, Amyris Biotechnology
- [Quoted here](http://research.microsoft.com/en-us/events/2012summerschool/kenjifsharpfphdsummerschool2012new.pdf)

With F#... we have written a complete genome re-sequencing pipeline with interface, algorithms, reporting in ~5K lines and it has been incredibly reliable, fast  and easy to maintain.

F# rocks - building out various algorithms for DNA processing here and it's like a drug.  Just implemented a suffix tree in 150 lines that can index 200,000 bases a second ;)    We have probably 10-20K lines of code for many scientific applications ranging from a full genome sequencing pipeline that reconstructs and annotated yeast strains, to simulators for various processes and design tools for building DNA sequences/constructs.  There are lab located apps that grab robot log files and move them to databases and a tool for viewing a huge collection of DNA sequencing data.

F# has been phenomenally useful.  I would be writing a lot of this in Python otherwise and F# is more robust, 20x - 100x faster to run and for anything but the most trivial programs, faster to develop.  The UI  work is especially gratifying, because state of the art for a lot of genomic data display is still PNG images embedded in JavaScript and with F# I can render half a million data points on a web page without jumping through hoops.

With Units of Measure I started labelling the coordinates as one or zero based and immediately found a bug where I'd casually mixed the two systems. Yay F#!

---

> I evaluated F# and it and found that for certain tasks it was better 
> than C# in terms of performance while maintaining suitable readability

- **Atalasoft**
- [Blog post](http://www.atalasoft.com/cs/blogs/stevehawley/archive/2011/08/01/building-pure-managed-dotimage.aspx)

I evaluated F# and it and found that for certain tasks it was better than C# in terms of performance while maintaining suitable readability and for certain tasks, it leant itself better to certain algorithms (OctTree based color quantization stands out). It was far from perfect. For example, I wrote a very straight forward LRU scanline cache in F# based on internal types and found that the cache was bottlenecking in the generic aggregate classes I was using. There was nothing in my control that I could do to make those internal classes perform better other than to reimplement the cache in side-effect-heavy C#. After doing that, the cost of cache operations in my benchmarks vanished, which is how it should be. …we were able to heavily leverage inline functions in F#...…Since each of these are inlines, the F# optimizer can actually do something useful with the code. In my experience so far, the C# optimizer doesn’t really do much, if anything. So why do we care about this? It’s that lurking 1.5x managed code cost. In my measurements, C#->IL->target CPU does about 1.5x the work of C++->target CPU. Quite honestly, for a virtual language to a virtual machine, this is a very low cost. By using F#, we were able to address this cost by using inlining, code profiling, scanline caching, memoization and other techniques. In many cases we ended up with code that ran in equivalent time to C++ code or in some cases faster.

---

> ...my predecessor developed an entire pension quote calculator (typically scheduled to take 300-400 man days) entirely in F# in under 100 days with no prior F# experience at all...

- **Jon Harrop**
- [reference](http://stackoverflow.com/questions/952318/what-are-the-benefits-of-using-c-sharp-vs-f-or-f-vs-c), [reference](http://www.quora.com/Which-organizations-use-the-F-programming-language-in-a-non-trivial-fashion/answer/Jon-Harrop-1), [reference](http://stackoverflow.com/questions/179332/anyone-actually-using-f-in-production)

Aviva (one of the world's largest insurance companies) have F# code in production, are starting several more projects in F#. We are currently consulting for Aviva (£2.5bn profit) who have migrated some of their number crunching and business logic to F# and are so happy with the results (10x faster and 10x less code vs their Visual C++ 6) that they are proposing to migrate 1,600,000 lines of code to F#. In particular, their developers found F# easy to learn and use.

… my predecessor developed an entire pension quote calculator (typically scheduled to take 300-400 man days) entirely in F# in under 100 days with no prior F# experience at all. Performance is 10× better than the C++ that it replaces because the new code avoids unnecessary copying and exploits multicore parallelism. Part of my job here will be to give basic F# training to around 20 people and bring a few people up to expert level.

In answer to "Can you give any evidence for 10x performance gain over C++?". Aviva's C++ code is a simple manual translation from very inefficient Mathematica code that suffers from several pathological performance problems mainly centered around excessive copying. The F# rewrite does not have these problem. The 10x performance gain was verified by the client.



---


> At Credit Suisse, we've been using it to develop quantitative models for financial products. 

- **Howard Mansell**, Credit Suisse
- [CUFP Workshop, 2008](http://cufp.org/archive/2008/abstracts.html#MansellHoward)

Building valuation models for derivative trades requires rapid development of mathematical models, made possible by composition of lower-level model components. We have found that F#, with the associated toolset, provides a unique combination of features that make it very well suited to this kind of development. In this talk, I will explain how we are using F# and show why it is a good match. I will also talk about the problems we have had, and outline future enhancements that would benefit this kind of work.

Here's a link to a talk abstract from a Commercial Users of Functional Programming workshop: http://cufp.org/archive/2008/abstracts.html#MansellHoward

---

> Banking Firm Uses Functional Language to Speed Development by 50 
> Percent

- **Microsoft Case Study**
- [Link](http://www.microsoft.com/casestudies/Case_Study_Detail.aspx?casestudyid=4000006794)

A large financial services firm in Europe sought new development tools that could cut costs, boost productivity, and improve the quality of its mathematical models. To address its needs, the bank deployed Microsoft F#, the Microsoft .NET Framework, and Microsoft Visual Studio. It will soon upgrade to Visual Studio 2010 and the integrated Microsoft Visual F#. With its new tools, the bank can speed development by 50 percent or more, improve quality, and reduce costs.

---

> The use of F# to address the complexity at the heart of this 
> application clearly demonstrates a sweet spot for the language within 
> enterprise software
	
- Simon Cousins, UK-based Energy Company
- [link](http://stackoverflow.com/questions/2785029/in-what-areas-might-the-use-of-f-be-more-appropriate-than-c)

I have written an application to balance the national power generation schedule for a portfolio of power stations to a trading position for an energy company. The client and server components were in C# but the calculation engine was written in F#.  The use of F# to address the complexity at the heart of this application clearly demonstrates a sweet spot for the language within enterprise software, namely algorithmically complex analysis of large data sets. My experience has been a very positive one. In particular:

**Units of measure** - The industry I work in is littered with units. The equations I implemented (often of a geometric nature) dealt with units of time, power and energy. Having the type system verify the correctness of the units of the inputs and outputs of functions is a huge time saver, both in terms of testing and reading/understanding the code. It eradicates a whole class of errors that previous systems were prone to.

**Exploratory programming** - Working with script files and the REPL (F# Interactive) allowed me to explore the solution space more effectively before committing to an implementation than the more traditional edit/compile/run/test loop. It is a very natural way for a programmer to build their understanding of the problem and the design tensions in play.

**Unit testing** - Code written using non-side effecting functions and immutable data structures is a joy to test. There are no complex time-dependent interactions to screw things up or large sets of dependencies to be mocked.

**Interoperation** - I defined the interface to the calculation engine in C# and implemented the calculation in F#. The calculation engine could then be injected into any C# module that needed to use it without any concerns at all about interoperability. Seamless. The C# programmer need never know.

**Code reduction** - Much of the data fed into the calculation engine was in the form of vectors and matrices. Higher order functions eat these for breakfast with minimal fuss, minimal code. Beautiful.

**Lack of bugs** -  Functional programming can feel strange. I can be working on an algorithm, trying hard to get the code to pass the type checker but once the type checker is satisfied thats it, it works. Its almost binary, either it wont compile or its correct. Weird edge case errors are minimised, recursion and higher order functions remove a lot of book-keeping code that introduces edge case errors.

**Parallelism** - The functional purity of the resulting implementation makes it ripe for exploiting the inherent parallelism in processing vectors of data. Maybe this is where I will go next now that .NET 4 is out. 

---

> This software provides the user with maximum flexibility to move 
> quickly through multiple images

- [**Forensic Software**](http://www.forensic-software.com/)

Forensic Comparison Software is the ideal tool for displaying two digital images, side by side, for comparison purposes. This software provides the user with maximum flexibility to move quickly through multiple images, in a manner that replaces the intensive manual comparison of hard copy photographs. Focusing on the individual’s needs, Forensic Comparison Software provides many intuitive and easy to use features for enhancing digital images.

---

> Software developers at Genetec use their technical aptitudes 
> creatively in order to design and program new features

- [Montreal-based IP Security Company](http://www.linkedin.com/groups/I-am-looking-Software-Developer-2347131.S.125972690)

Software developers at Genetec use their technical aptitudes creatively in order to design and program new features, while working closely with the product management teams to meet customers’ expectations. They work in multidisciplinary teams driven by the desire to overcome the limits of the technology in order to deliver products of outstanding quality, beauty and creativity to the customers. A software development career at Genetec is much more than just an opportunity to create great products; it is also an opportunity to work in a world class, talented, high energy software development team with a solid track record of creating winning products. 

The current position is a code intensive position specialized in distributed applications development using functional programming and .Net technologies. Design and implement large scale distributed network centric applications using .NET 4.0 technologies in F#.


---

> Grange Insurance parallelized its rating engine to take better 
> advantage of multicore server hardware

- [Grange Insurance](http://www.microsoft.com/casestudies/case_study_detail.aspx?casestudyid=4000005226)

For nearly 75 years, Grange Insurance has offered competitive products and services to policyholders in more than a dozen U.S. states. To maintain its well-earned reputation and standing, the company decided to enhance its rating engine—a software tool for rating policies and performing what-if modeling, impact analyses, and other vital activities. Working with the Sophic Group and using the Microsoft® Visual Studio® Team System development environment and Microsoft Visual F# programming language, Grange Insurance parallelized its rating engine to take better advantage of multicore server hardware, and in so doing garnered significant performance benefits. Processes that used to require hours now take just minutes, enabling the company to trim time-to-market by weeks and making it far easier for independent agents to sell and service Grange products.


---

> Bohdan ... shows F#'s use for performing aggregations over large 
> datasets, taking advantage of cpu and io parallelism
	
- [link to public talk](http://dnufba.preview.intergen.net.nz/Lists/Events%20Calendar/DispForm.aspx?ID=279)

Bohdan Szymanik, CTO at Kiwibank, is keen to show how he’s been using F# for analysis tasks within the bank. He’ll provide an intro to the language then show its use for performing aggregations over large datasets, taking advantage of cpu and io parallelism, and data presentation through charting and image generation.

---

> Around 95% of the code in these projects has been developed in F#

- [F# in Advertisement Ranking & Rating @ Microsoft](http://research.microsoft.com/en-us/events/2012summerschool/kenjifsharpfphdsummerschool2012new.pdf)

Around 95% of the code in these projects has been developed in F#.
• F# allowed for rapid development of prototypes, and thus also rapid verification or falsification of the underlying mathematical models.
• Complex algorithms, for example to compute Nash equilibria in game theory, can be expressed succinctly.
• Units of measure reduced the chance of errors dramatically: Prices, probabilities, derivatives, etc. can already be kept apart at compile time.

---

> F#’s powerful type inference means less typing, more thinking

- Don Syme, Principal Researcher
- [Eclipse Summit Europe 2009](http://www.slideshare.net/lgayowski/taking-functional-programming-into-the-mainstream-eclipse-summit-europe-2009, slide 49)

F# was used on Microsoft “AdPredict” project for Microsoft adCenter. This was a 4 week project with 4 machine learning experts involving a model with 100million probabilistic variables and processing 6TB of training data in real-time. 2 weeks of CPU time were used during training: 

What We Observed:
**Quick Coding** - F#’s powerful type inference means less typing, more thinking **Agile Coding** - Type-inferred code is easily refactored
**Scripting** - “Hands-on” exploration.
**Performance** - Immediate scaling to massive data sets
**Memory-Faithful** - mega-data structures on 16GB machines
**Succinct** - Live in the domain, not the language
**Symbolic** - Schema compilation and “Schedules”
**.NET Integration** - Especially Excel, SQL Server

---

> F# allows you to move smoothly in your programming style

- [Julien Laugel, eurostocks.com](http://www.slideshare.net/lgayowski/taking-functional-programming-into-the-mainstream-eclipse-summit-europe-2009), slide 19

I’ve been coding in F# lately, for a production task. F# allows you to move smoothly in your programming style... I start with pure functional code, shift slightly towards an object-oriented style, and in production code, I sometimes have to do some imperative programming. I can start with a pure idea, and still finish my project with realistic code. You’re never disappointed in any phase of the project!


